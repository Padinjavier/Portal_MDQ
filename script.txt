C:\wamp64\www\helpmdq\script.txt

1Ô∏è‚É£ Reasignar IDs de la tabla usuarios de forma secuencial:
SET @new_id = 0;
UPDATE `usuarios` 
SET `IdUsuario` = (@new_id := @new_id + 1) 
ORDER BY `IdUsuario`;
‚úÖ Esto reinicia los IDs de usuarios, asegurando que comiencen en 1 y aumenten secuencialmente.



2Ô∏è‚É£ Otorgar acceso total al administrador (IdRol = 1) en todos los m√≥dulos:
INSERT INTO `helpdesk`.`permisos` (`IdRol`, `IdModulo`, `R`, `W`, `U`, `D`)
SELECT 1, `IdModulo`, 1, 1, 1, 1 FROM `modulos`;
‚úÖ Este c√≥digo asigna permisos de lectura (R), escritura (W), actualizaci√≥n (U) y eliminaci√≥n (D) a todos los m√≥dulos para el administrador.


1Ô∏è‚É£ Trigger para insertar permisos cuando se crea un nuevo rol
Cada vez que se agrega un nuevo rol, este disparador buscar√° todos los m√≥dulos existentes y crear√° un permiso para cada uno con los valores R=0, W=0, U=0, D=0.

DELIMITER $$
CREATE TRIGGER after_insert_rol
AFTER INSERT ON rol
FOR EACH ROW
BEGIN
    INSERT INTO permisos (IdRol, IdModulo, R, W, U, D)
    SELECT NEW.IdRol, IdModulo, 0, 0, 0, 0 FROM modulos;
END $$
DELIMITER ;

üìå Explicaci√≥n:
NEW.IdRol ‚Üí Obtiene el ID del nuevo rol insertado.
SELECT IdModulo FROM modulos ‚Üí Obtiene todos los m√≥dulos existentes y los inserta en la tabla permisos para este nuevo rol.

2Ô∏è‚É£ Trigger para insertar permisos cuando se crea un nuevo m√≥dulo
Cada vez que se agrega un nuevo m√≥dulo, este disparador buscar√° todos los roles existentes y asignar√° un nuevo permiso con R=0, W=0, U=0, D=0.

DELIMITER $$
CREATE TRIGGER after_insert_modulo
AFTER INSERT ON modulos
FOR EACH ROW
BEGIN
    INSERT INTO permisos (IdRol, IdModulo, R, W, U, D)
    SELECT IdRol, NEW.IdModulo, 0, 0, 0, 0 FROM rol;
END $$
DELIMITER ;

üìå Explicaci√≥n:
NEW.IdModulo ‚Üí Obtiene el ID del nuevo m√≥dulo insertado.
SELECT IdRol FROM rol ‚Üí Obtiene todos los roles existentes y les asigna el nuevo m√≥dulo en permisos.

3Ô∏è‚É£ Trigger para reordenar los IDs de los permisos agrupados por rol
Cada vez que se agrega un nuevo m√≥dulo y se asigna a los roles, este trigger se asegurar√° de que los permisos est√©n agrupados por IdRol de forma consecutiva.
¬øC√≥mo funciona?
Obtiene el nuevo m√≥dulo agregado.
Reasigna los IDs de los permisos de manera ordenada por IdRol.

DELIMITER $$
CREATE TRIGGER after_insert_permisos
AFTER INSERT ON permisos
FOR EACH ROW
BEGIN
    SET @new_id = 0;
    -- Reordenar los permisos para que los de cada rol est√©n juntos y en orden
    UPDATE permisos AS p
    JOIN (
        SELECT IdPermiso, (@new_id := @new_id + 1) AS new_id
        FROM permisos ORDER BY IdRol, IdPermiso
    ) AS temp ON p.IdPermiso = temp.IdPermiso
    SET p.IdPermiso = temp.new_id;
END $$
DELIMITER ;

üìå Explicaci√≥n:
Se crea una variable @new_id que empieza en 0.
Se reordena la tabla permisos agrupando primero por IdRol y asignando IDs secuenciales.
As√≠, los permisos del Rol 1 estar√°n siempre juntos, luego los del Rol 2, etc.



medicion de tiempos de carga de las secicones
let tiempos = [];
let iteraciones = 10; // N√∫mero de veces que recargar√°

async function medirCarga() {
    for (let i = 0; i < iteraciones; i++) {
        let inicio = performance.now();
        await fetch(window.location.href, { cache: "reload" }); // Recarga sin cach√©
        let fin = performance.now();
        let tiempoCarga = fin - inicio;
        tiempos.push(tiempoCarga);
        console.log(`Carga ${i + 1}: ${tiempoCarga.toFixed(2)} ms`);
    }
    
    let promedio = tiempos.reduce((a, b) => a + b, 0) / tiempos.length;
    console.log(`Tiempo promedio de carga: ${promedio.toFixed(2)} ms`);
}

medirCarga();
